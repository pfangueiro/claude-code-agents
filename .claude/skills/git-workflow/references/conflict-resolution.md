# Conflict Resolution — Advanced Patterns

Strategies for resolving merge conflicts effectively and preventing them from recurring.

---

## Understanding Conflict Types

### Content Conflicts
Two branches modify the same lines in the same file.

```
<<<<<<< HEAD (your changes)
const timeout = 5000;
=======
const timeout = 10000;
>>>>>>> feature/update-timeout
```

**Resolution:** Understand the intent of both changes, pick the correct value (or combine them).

### Structural Conflicts
One branch modifies a function while another branch moves or renames it.

**Resolution:** Requires understanding the full context — often needs manual reconstruction.

### Semantic Conflicts
Changes don't conflict textually but break logic when combined. Git won't detect these.

Example: Branch A adds a required parameter to a function, Branch B calls that function without the new parameter.

**Resolution:** Tests catch these — always run the full test suite after resolving conflicts.

---

## Resolution Strategies

### Strategy 1: Rebase and Resolve Incrementally

Best when your branch has many commits and conflicts span multiple changes.

```bash
git fetch origin
git rebase origin/main

# Conflicts appear one commit at a time
# Resolve each, then:
git add <resolved-files>
git rebase --continue

# If a commit becomes empty after resolution:
git rebase --skip

# To abort and start over:
git rebase --abort
```

**Advantage:** Resolve conflicts in small, understandable chunks.

### Strategy 2: Merge and Resolve All at Once

Best when conflicts are minor or your branch has few commits.

```bash
git fetch origin
git merge origin/main

# Resolve all conflicts
git add <resolved-files>
git commit  # Git provides a merge commit message
```

**Advantage:** Simpler, preserves full history.

### Strategy 3: Ours/Theirs for Bulk Resolution

When you know one side is entirely correct:

```bash
# Accept all of their changes for a file
git checkout --theirs path/to/file.ts
git add path/to/file.ts

# Accept all of your changes for a file
git checkout --ours path/to/file.ts
git add path/to/file.ts
```

**Warning:** Only use when you're certain one side is completely correct.

---

## Complex Conflict Patterns

### Lock File Conflicts (package-lock.json, yarn.lock)

Never manually resolve lock file conflicts. Regenerate instead:

```bash
# Accept theirs, then regenerate
git checkout --theirs package-lock.json
npm install
git add package-lock.json
```

### Auto-Generated File Conflicts

For files generated by tools (migrations, schemas, codegen):

```bash
# Accept one side, then regenerate
git checkout --theirs <generated-file>
# Run the generation command
npm run generate
git add <generated-file>
```

### Rename/Modify Conflicts

When one branch renames a file and the other modifies it:

```bash
# Git may not detect the rename — check manually
git log --follow --diff-filter=R -- <old-path>

# Apply the changes to the new filename
git show HEAD:<old-path> > <new-path>  # If needed
# Manually merge the content
git add <new-path>
git rm <old-path>
```

---

## Prevention Strategies

### 1. Keep Branches Short-Lived
- The longer a branch lives, the more likely conflicts become
- Merge or rebase from main at least daily
- Break large features into smaller PRs

### 2. Communicate About Shared Files
- If you know another developer is modifying the same area, coordinate
- Use draft PRs to signal work in progress
- Review the active branch list before starting work on shared code

### 3. Reduce Shared Mutable State in Code
- Smaller, focused files reduce conflict surface area
- Avoid "god files" that everything depends on
- Use barrel exports (`index.ts`) carefully — they're frequent conflict sources

### 4. Consistent Formatting
- Use automated formatters (Prettier, Black, gofmt)
- Run formatters on save or pre-commit
- Eliminates conflicts caused by whitespace/formatting differences

### 5. Rebase Before Creating PR
```bash
# Always rebase before opening a PR
git fetch origin
git rebase origin/main
# Resolve any conflicts locally before the reviewer sees them
```

---

## Tooling

### git mergetool
```bash
# Configure a merge tool
git config --global merge.tool vimdiff

# Launch during conflict resolution
git mergetool
```

### Useful Commands During Resolution
```bash
# See which files are conflicted
git diff --name-only --diff-filter=U

# See the common ancestor version
git show :1:path/to/file

# See "ours" version
git show :2:path/to/file

# See "theirs" version
git show :3:path/to/file

# Abort a merge
git merge --abort

# Abort a rebase
git rebase --abort
```

### Rerere (Reuse Recorded Resolution)
Git can remember how you resolved a conflict and apply the same resolution automatically next time:

```bash
# Enable rerere
git config --global rerere.enabled true

# Git will now record and replay conflict resolutions
```
